// install

value type Coord {(Int,Int)}  // x,y
def x(c in Coord, v): ^Coord(v, _, c)
def y(c in Coord, v): ^Coord(_, v, c)

def game_width { 24 }
def game_height { 24 }

def grid { ^Coord[
    range[-1 * game_width, game_width, 1],
    range[-1 * game_height, game_height, 1]
]}

// ----------------------------
declare mine(v...) requires {Coord}(v...)

// Mines are placed randomly throughout the infinite grid. Since they're infinite, we can't
// compute them all, and instead they must be _derived_ based on a function of the
// coordinate. We use a hash function to do this.

// @ondemand
@inline
def mine(c in Coord): {
    // The original game has 40 mines in a 16x16 grid, or 256 cells.
    // Rate of seeds: 40 / 256 = 15.625%, or 10 in 64
    (murmurhash3f_with_seed[seed, c] % 64) < 10  // 15.625%
}

// ----------------------------

// @ondemand
@inline
def neighbor[c in grid]: (out): {
    exists((x2, y2) | {
        out = ^Coord[x2, y2]
        where {( c.y )-1; ( c.y ); ( c.y )+1}(y2)
          and {( c.x )-1; ( c.x ); ( c.x )+1}(x2)
          and not (x2 = (c.x) and y2 = (c.y))
    })
}

@inline
def mine_count[c in grid]: {
    count[(n): mine(n) where neighbor(c, n)]
}

declare test(vs...) requires {Coord}(vs...)
def correct_test(c in test): {
    not mine(c)
}

def exploded_mine(c in test): {
    mine(c)
}
ic () requires disjoint(correct_test, exploded_mine)

// This should now be concrete! It will stop when it encounters enough mines.
def revealed(c in grid): { correct_test(c) }
def revealed(c in grid): {
    exists((r) | neighbor(r, c) where
        revealed(r)
        and empty(( r.mine_count )))
}

declare flag(vs...) requires {Coord}(vs...)
def correct_flag(c in flag): {
    mine(c)
}

ic () requires disjoint(flag, test)

// Game moves
declare insert(:test, vs...) requires {[:test] : Coord}(:test, vs...)
declare insert(:flag, vs...) requires {[:flag] : Coord}(:flag, vs...)

// no cheating :P
// ic { not count[insert:test] > 1 }
// ic { not count[insert:flag] > 1 }
